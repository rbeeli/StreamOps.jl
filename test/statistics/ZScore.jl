@testitem "reset!" begin
    op = ZScore{Float64,Float64}(3)

    @test !is_valid(op)

    op(nothing, 1.0)
    op(nothing, 2.0)
    op(nothing, 3.0)

    @test is_valid(op)
    reset!(op)
    @test !is_valid(op)
end

@testitem "window_size=5 corrected=true(default)" begin
    using Dates

    window_size = 5

    g = StreamGraph()

    vals = [1.0, 2.0, 3.0, 4.0, 1.0, 2.0, 3.0, 4.0, 1.0, 2.0]
    values_data = Tuple{DateTime,Float64}[
        (DateTime(2000, 1, i), x)
        for (i, x) in enumerate(vals)
    ]

    values = source!(g, :values, HistoricIterable(Float64, values_data))
    zscore = op!(g, :zscore, ZScore{Float64,Float64}(window_size), out=Float64)
    output = sink!(g, :output, Buffer{Float64}())

    bind!(g, values, zscore)
    bind!(g, zscore, output)

    states = compile_graph!(DateTime, g)
    exe = HistoricExecutor{DateTime}(g, states)
    setup!(exe)

    start = DateTime(2000, 1, 1)
    stop = DateTime(2000, 1, length(vals))
    run!(exe, start, stop)

    # Reference values generated by pandas, see ./ZScore.py
    expected = [-0.9203579866168446, -0.35082320772281156,
        0.35082320772281156, 0.9203579866168446, -0.9203579866168446, -0.35082320772281156]
    @test output.operation.buffer ≈ expected
end

@testitem "window_size=3 corrected=false" begin
    using Dates
    
    window_size = 3

    g = StreamGraph()

    vals = [1.0, 2.0, 3.0, 4.0, 1.0, 2.0, 3.0, 4.0, 1.0, 2.0]
    values_data = Tuple{DateTime,Float64}[
        (DateTime(2000, 1, i), x)
        for (i, x) in enumerate(vals)
    ]

    values = source!(g, :values, HistoricIterable(Float64, values_data))
    zscore = op!(g, :zscore, ZScore{Float64,Float64}(window_size, corrected=false), out=Float64)
    output = sink!(g, :output, Buffer{Float64}())

    bind!(g, values, zscore)
    bind!(g, zscore, output)

    states = compile_graph!(DateTime, g)
    exe = HistoricExecutor{DateTime}(g, states)
    setup!(exe)

    start = DateTime(2000, 1, 1)
    stop = DateTime(2000, 1, length(vals))
    run!(exe, start, stop)

    # Reference values generated by pandas, see ./ZScore.py
    expected = [1.224744871391589, 1.224744871391589, -1.3363062095621219, -0.2672612419124245,
        1.224744871391589, 1.224744871391589, -1.3363062095621219, -0.2672612419124245]
    @test output.operation.buffer ≈ expected
end

@testitem "Edge case: Single value" begin
    using Dates
    
    window_size = 1
    g = StreamGraph()
    values_data = Tuple{DateTime,Float64}[(DateTime(2000, 1, 1), 1.0)]
    values = source!(g, :values, HistoricIterable(Float64, values_data))
    zscore = op!(g, :zscore, ZScore{Float64,Float64}(window_size), out=Float64)
    output = sink!(g, :output, Buffer{Float64}())
    bind!(g, values, zscore)
    bind!(g, zscore, output)

    states = compile_graph!(DateTime, g)
    exe = HistoricExecutor{DateTime}(g, states)
    setup!(exe)

    start = DateTime(2000, 1, 1)
    stop = DateTime(2000, 1, 1)
    run!(exe, start, stop)

    # we define Z-score as 0 for a single value
    @test output.operation.buffer[1] == 0
    @test length(output.operation.buffer) == 1
end

@testitem "Edge case: Constant values" begin
    using Dates
    
    window_size = 5
    g = StreamGraph()
    constant_vals = [2.0, 2.0, 2.0, 2.0, 2.0, 2.0]
    values_data = Tuple{DateTime,Float64}[
        (DateTime(2000, 1, i), x)
        for (i, x) in enumerate(constant_vals)
    ]
    values = source!(g, :values, HistoricIterable(Float64, values_data))
    zscore = op!(g, :zscore, ZScore{Float64,Float64}(window_size), out=Float64)
    output = sink!(g, :output, Buffer{Float64}())
    bind!(g, values, zscore)
    bind!(g, zscore, output)

    states = compile_graph!(DateTime, g)
    exe = HistoricExecutor{DateTime}(g, states)
    setup!(exe)
    start = DateTime(2000, 1, 1)
    stop = DateTime(2000, 1, length(constant_vals))
    run!(exe, start, stop)

    for i in eachindex(output.operation.buffer)
        # Z-score should be NaN for constant values (std dev = 0)
        @test isnan(output.operation.buffer[i])
    end
end
